const v = Object.freeze({ number: () => new class { constructor() { this.err = [] } default(r) { return !0 === this._optional && this.err.push(new Error("number.default() cannot have a default value")), ("number" != typeof r || isNaN(r)) && this.err.push(new Error("number.default() must be a number")), this.wholeNumber && !Number.isInteger(r) && this.err.push(new Error("number.default() must be a whole number")), void 0 !== this._min && r < this._min && this.err.push(new Error("number.default() must be greater than number.min()")), void 0 !== this._max && r > this._max && this.err.push(new Error("number.default() must be less than number.max()")), this._default = r, this } min(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("number.min() must be a number")), void 0 !== this._max && r > this._max && this.err.push(new Error("number.min() must be less than number.max()")), this.wholeNumber && !Number.isInteger(r) && this.err.push(new Error("number.min() must be a whole number")), void 0 !== this._default && r > this._default && this.err.push(new Error("number.min() must be less than number.default()")), this._min = r, this } max(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("number.max() must be a number")), void 0 !== this._min && r < this._min && this.err.push(new Error("number.max() must be greater than number.min()")), this.wholeNumber && !Number.isInteger(r) && this.err.push(new Error("number.max() must be a whole number")), void 0 !== this._default && r < this._default && this.err.push(new Error("number.max() must be greater than number.default()")), this._max = r, this } isWhole() { return void 0 === this._default || Number.isInteger(this._default) || this.err.push(new Error("number.isWhole() default value must be a whole number")), void 0 === this._min || Number.isInteger(this._min) || this.err.push(new Error("number.isWhole() min value must be a whole number")), void 0 === this._max || Number.isInteger(this._max) || this.err.push(new Error("number.isWhole() max value must be a whole number")), this.wholeNumber = !0, this } optional() { return void 0 !== this._default && this.err.push(new Error("number.optional() cannot have a default value")), this._optional = !0, this } validate(r) { return this.err.length > 0 ? [this.err, void 0] : this._optional && null == r ? [[], r] : void 0 !== this._default && null == r ? [[], this._default] : "number" != typeof r || isNaN(r) ? [[new Error("number.validate() invalid number")], void 0] : void 0 !== this._min && r < this._min ? [[new Error("number.validate() number is less than minimum")], void 0] : void 0 !== this._max && r > this._max ? [[new Error("number.validate() number is greater than maximum")], void 0] : this.wholeNumber && !Number.isInteger(r) ? [[new Error("number.validate() number is not a whole number")], void 0] : [[], r] } errors() { return this.err } }, string: () => new class { constructor() { this.err = [] } default(r) { return !0 === this._optional && this.err.push(new Error("string.default() cannot have a default value")), "string" != typeof r && this.err.push(new Error("string.default() must be a string")), void 0 !== this._minlength && r.length < this._minlength && this.err.push(new Error("string.default() must be greater than string.minlength()")), void 0 !== this._maxlength && r.length > this._maxlength && this.err.push(new Error("string.default() must be less than string.maxlength()")), void 0 !== this._length && r.length !== this._length && this.err.push(new Error("string.default() must be equal to string.length()")), this._default = r, this } minlength(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("string.minlength() must be a number")), void 0 !== this._maxlength && r > this._maxlength && this.err.push(new Error("string.minlength() must be less than string.maxlength()")), void 0 !== this._default && r > this._default.length && this.err.push(new Error("string.minlength() must be less than string.default().length")), void 0 !== this._length && r !== this._length && this.err.push(new Error("string.minlength() must be equal to string.length()")), this._minlength = r, this } maxlength(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("string.maxlength() must be a number")), void 0 !== this._minlength && r < this._minlength && this.err.push(new Error("string.maxlength() must be greater than string.minlength()")), void 0 !== this._default && r < this._default.length && this.err.push(new Error("string.maxlength() must be greater than string.default().length")), void 0 !== this._length && r !== this._length && this.err.push(new Error("string.maxlength() must be equal to string.length()")), this._maxlength = r, this } length(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("string.length() must be a number")), void 0 !== this._default && r !== this._default.length && this.err.push(new Error("string.length() must be equal to string.default().length")), void 0 !== this._minlength && r < this._minlength && this.err.push(new Error("string.length() must be greater than string.minlength()")), void 0 !== this._maxlength && r > this._maxlength && this.err.push(new Error("string.length() must be less than string.maxlength()")), this._length = r, this } inCharset(r) { return "string" == typeof r && 0 !== r.length || this.err.push(new Error("string.inCharset() must be a string with at least one character")), this._charset = r, this } optional() { return void 0 !== this._default && this.err.push(new Error("string.optional() cannot have a default value")), this._optional = !0, this } validate(r) { if (this.err.length > 0) return [this.err, void 0]; if (this._optional && null == r) return [[], r]; if (void 0 !== this._default && null == r) return [[], this._default]; if ("string" != typeof r) return [[new Error("string.validate() invalid string")], void 0]; if (void 0 !== this._minlength && r.length < this._minlength) return [[new Error("string.validate() string is less than minimum length")], void 0]; if (void 0 !== this._maxlength && r.length > this._maxlength) return [[new Error("string.validate() string is greater than maximum length")], void 0]; if (void 0 !== this._length && r.length !== this._length) return [[new Error("string.validate() string is not the correct length")], void 0]; if (void 0 !== this._charset) for (let t = 0; t < r.length; t++)if (!this._charset.includes(r[t])) return [[new Error("string.validate() string contains invalid characters")], void 0]; return [[], r] } errors() { return this.err } }, boolean: () => new class { constructor() { this.err = [] } default(r) { return !0 === this._optional && this.err.push(new Error("boolean.default() cannot have a default value")), "boolean" != typeof r && this.err.push(new Error("boolean.default() must be a boolean")), this._default = r, this } optional() { return void 0 !== this._default && this.err.push(new Error("boolean.optional() cannot have a default value")), this._optional = !0, this } validate(r) { return this.err.length > 0 ? [this.err, void 0] : this._optional && null == r ? [[], r] : void 0 !== this._default && null == r ? [[], this._default] : "boolean" != typeof r ? [[new Error("boolean.validate() invalid boolean")], void 0] : [[], r] } errors() { return this.err } }, array: r => new class { constructor() { this.err = [], "object" == typeof r && null !== r && "function" == typeof r.validate || this.err.push(new Error("array() type is invalid")) } default(t) { if (!0 === this._optional && this.err.push(new Error("array.default() cannot have a default value")), Array.isArray(t) || this.err.push(new Error("array.default() must be an array")), void 0 !== this._minlength && t.length < this._minlength && this.err.push(new Error("array.default() must be greater than array.minlength()")), void 0 !== this._maxlength && t.length > this._maxlength && this.err.push(new Error("array.default() must be less than array.maxlength()")), void 0 !== this._length && t.length !== this._length && this.err.push(new Error("array.default() must be equal to array.length()")), "function" == typeof r.validate) for (let e = 0; e < t.length; e++) { const [n, i] = r.validate(t[e]); if (n.length > 0) { this.err.push(new Error(`array.default() element ${e} is invalid`)); break } } else this.err.push(new Error("array.default() type is invalid")); return this._default = t, this } minlength(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("array.minlength() must be a number")), void 0 !== this._maxlength && r > this._maxlength && this.err.push(new Error("array.minlength() must be less than array.maxlength()")), void 0 !== this._default && r > this._default.length && this.err.push(new Error("array.minlength() must be less than array.default().length")), void 0 !== this._length && r !== this._length && this.err.push(new Error("array.minlength() must be equal to array.length()")), this._minlength = r, this } maxlength(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("array.maxlength() must be a number")), void 0 !== this._minlength && r < this._minlength && this.err.push(new Error("array.maxlength() must be greater than array.minlength()")), void 0 !== this._default && r < this._default.length && this.err.push(new Error("array.maxlength() must be greater than array.default().length")), void 0 !== this._length && r !== this._length && this.err.push(new Error("array.maxlength() must be equal to array.length()")), this._maxlength = r, this } length(r) { return ("number" != typeof r || isNaN(r)) && this.err.push(new Error("array.length() must be a number")), void 0 !== this._default && r !== this._default.length && this.err.push(new Error("array.length() must be equal to array.default().length")), void 0 !== this._minlength && r < this._minlength && this.err.push(new Error("array.length() must be greater than array.minlength()")), void 0 !== this._maxlength && r > this._maxlength && this.err.push(new Error("array.length() must be less than array.maxlength()")), this._length = r, this } optional() { return void 0 !== this._default && this.err.push(new Error("array.optional() cannot have a default value")), this._optional = !0, this } validate(t) { if (this.err.length > 0) return [this.err, void 0]; if (this._optional && null == t) return [[], t]; if (void 0 !== this._default && null == t) return [[], this._default]; if (!Array.isArray(t)) return [[new Error("array.validate() invalid array")], void 0]; if (void 0 !== this._minlength && t.length < this._minlength) return [[new Error("array.validate() array is less than minimum length")], void 0]; if (void 0 !== this._maxlength && t.length > this._maxlength) return [[new Error("array.validate() array is greater than maximum length")], void 0]; if (void 0 !== this._length && t.length !== this._length) return [[new Error("array.validate() array is not the correct length")], void 0]; if ("function" != typeof r.validate) return [[new Error("array.validate() type is invalid"), void 0]]; for (let e = 0; e < t.length; e++) { const [n, i] = r.validate(t[e]); if (n.length > 0) return [[new Error(`array.validate() element ${e} is invalid`), void 0]]; t[e] = i } return [[], t] } errors() { let t = this.err; return "function" != typeof r.errors || "function" != typeof r.validate ? t.push(new Error("array.errors() type is invalid")) : t = t.concat(r.errors()), t } }, object: r => new class { constructor() { if (this.err = [], null == r) return [[new Error("object.validate() invalid object")], void 0]; for (const t in r) "function" != typeof r[t].validate && this.err.push(new Error(`object() key ${t} is invalid`)) } optional() { return this._optional = !0, this } validate(t) { if (this.err.length > 0) return [this.err, void 0]; if (this._optional && null == t) return [[], t]; if (void 0 !== this._default && null == t) return [[], this._default]; if ("object" != typeof t || null === t) return [[new Error("object.validate() invalid object")], void 0]; for (const e in r) { if ("function" != typeof r[e].validate) return [[new Error(`object.validate() key ${e} is invalid`), void 0]]; const [n, i] = r[e].validate(t[e]); if (n.length > 0) return [[new Error(`object.validate() key ${e} is invalid`), void 0]]; t[e] = i } return [[], t] } errors() { let t = this.err; for (const e in r) "function" != typeof r[e].validate || "function" != typeof r[e].errors ? t.push(new Error(`object.errors() key ${e} is invalid`)) : t = t.concat(r[e].errors()); return t } }, equal: r => new class { validate(t) { return t !== r ? [[new Error("equal.validate() values are not equal")], void 0] : [[], t] } errors() { return [] } }, or: (...r) => new class { constructor() { this.err = [], 0 === r.length && this.err.push(new Error("or() must be given at least one type")); for (let t = 0; t < r.length; t++)"function" != typeof r[t].validate && this.err.push(new Error("or() all types must have a validate function")) } default(t) { if (!0 === this._optional) return this.err.push(new Error("or.default() cannot have a default value")), this; for (let e = 0; e < r.length; e++) { const [n, i] = r[e].validate(t); if (0 === n.length) return this._default = i, this } return this } optional() { return void 0 !== this._default ? (this.err.push(new Error("or.optional() cannot have a default value")), this) : this } validate(t) { if (this.err.length > 0) return [this.err, void 0]; if (this._optional && null == t) return [[], t]; if (void 0 !== this._default && null == t) return [[], this._default]; for (let e = 0; e < r.length; e++) { const [n, i] = r[e].validate(t); if (0 === n.length) return [[], i] } return [[new Error("or.validate() no types matched")], void 0] } errors() { return this.err } } }); "undefined" != typeof module && (module.exports = v);